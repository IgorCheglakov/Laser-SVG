/**
 * SVG Export Utility
 * 
 * Converts PointElement array to SVG string compatible with Lightburn.
 */

import type { PointElement, SVGElement } from '@/types-app/index'

/**
 * Generate SVG path data for points with Bezier curve support
 */
function generatePathData(points: PointElement['points'], isClosed: boolean): string {
  if (points.length === 0) return ''
  
  let d = ''
  
  for (let i = 0; i < points.length; i++) {
    const p = points[i]
    const px = p.x
    const py = p.y
    
    if (i === 0) {
      d += `M ${px} ${py}`
    } else {
      const prev = points[i - 1]
      
    // Use nextControlHandle from previous point (outgoing) and prevControlHandle from current point (incoming)
    const hasCp1 = prev.nextControlHandle && (prev.vertexType === 'corner' || prev.vertexType === 'smooth')
    const hasCp2 = p.prevControlHandle && (p.vertexType === 'corner' || p.vertexType === 'smooth')
    
    if (hasCp1 || hasCp2) {
      const cp1x = prev.nextControlHandle ? prev.nextControlHandle.x : px
      const cp1y = prev.nextControlHandle ? prev.nextControlHandle.y : py
      const cp2x = p.prevControlHandle ? p.prevControlHandle.x : px
      const cp2y = p.prevControlHandle ? p.prevControlHandle.y : py
        d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${px} ${py}`
      } else {
        d += ` L ${px} ${py}`
      }
    }
  }
  
  // Close path for closed shapes
  if (isClosed && points.length > 2) {
    const first = points[0]
    const last = points[points.length - 1]
    
    // Use nextControlHandle from last (outgoing) and prevControlHandle from first (incoming)
    const hasCp1 = last.nextControlHandle && (last.vertexType === 'corner' || last.vertexType === 'smooth')
    const hasCp2 = first.prevControlHandle && (first.vertexType === 'corner' || first.vertexType === 'smooth')
    
    if (hasCp1 || hasCp2) {
      const cp1x = last.nextControlHandle ? last.nextControlHandle.x : first.x
      const cp1y = last.nextControlHandle ? last.nextControlHandle.y : first.y
      const cp2x = first.prevControlHandle ? first.prevControlHandle.x : first.x
      const cp2y = first.prevControlHandle ? first.prevControlHandle.y : first.y
      d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${first.x} ${first.y}`
    }
    
    d += ' Z'
  }
  
  return d
}

/**
 * Export elements to SVG string
 */
export function exportToSVG(elements: SVGElement[], _width: number, _height: number): string {
  const timestamp = Date.now()
  
  const canvasX = 0
  const canvasY = 0
  const canvasWidth = 1000
  const canvasHeight = 1000
  
  const svgLines: string[] = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<svg xmlns="http://www.w3.org/2000/svg" width="${canvasWidth}mm" height="${canvasHeight}mm" viewBox="${canvasX} ${canvasY} ${canvasWidth} ${canvasHeight}">`,
  ]
  
  // Add metadata for LaserSVG compatibility check
  svgLines.push(`  <metadata>`)
  svgLines.push(`    <isLaserSvgCompatible>true</isLaserSvgCompatible>`)
  svgLines.push(`    <timestamp>${timestamp}</timestamp>`)
  svgLines.push(`  </metadata>`)
  
  // Add metadata for Lightburn compatibility
  svgLines.push(`  <!-- Generated by LaserSVG Editor -->`)
  svgLines.push(`  <g id="layer1">`)
  
  for (const element of elements) {
    if (!('points' in element) || !element.points || !element.visible) continue
    
    const pointEl = element as PointElement
    const d = generatePathData(pointEl.points, pointEl.isClosedShape)
    
    if (!d) continue
    
    const stroke = pointEl.stroke || '#000000'
    const strokeWidth = pointEl.strokeWidth || 0.25
    
    svgLines.push(`    <path`)
    svgLines.push(`      d="${d}"`)
    svgLines.push(`      fill="none"`)
    svgLines.push(`      stroke="${stroke}"`)
    svgLines.push(`      stroke-width="${strokeWidth}"`)
    svgLines.push(`      stroke-linecap="round"`)
    svgLines.push(`      stroke-linejoin="round"`)
    
    if (element.name) {
      svgLines.push(`      id="${element.id}"`)
      svgLines.push(`      data-name="${element.name}"`)
    }
    
    svgLines.push(`    />`)
  }
  
  svgLines.push(`  </g>`)
  svgLines.push(`</svg>`)
  
  return svgLines.join('\n')
}
